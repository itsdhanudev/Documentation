# Vetor3.divEqual()

Método de instância em `Vector3`.

## Descrição

- Divides this Vector3 by the specified object. |

## Method Signature

```java
divEqual(Object)
```

## Mathematical Definition

`Component-wise or runtime-defined transformation based on overload.`

## Parameters

- `Object`: polymorphic operand; runtime resolves supported numeric/vector types.

## Retorna

- `void`: returned by overloads of this method.

## Mutability

- Mutates o atual vector (in-place).

## Edge Cases

- Division by zero can produce `Infinity` or `NaN`.
- Very small denominators amplify floating-point noise.
- Runtime-specific guarding/clamping may apply in engine internals.

## Usage Example

```java
Vector3 a = new Vector3(1f, 2f, 3f);
// Call the method according to your overload requirements.
// Example:
// a.divEqual(...);
```

## Mathematical Example

Example input/output depends on overload; for vector arithmetic operations this is typically computed per-component.

## Visualization

### p5.js HTML Source

```html
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
      html, body { margin: 0; padding: 0; background: #0b1020; }
      #sketch { width: 100vw; height: 100vh; overflow: hidden; }
    </style>
  </head>
  <body>
    <div id="sketch"></div>
    <script>
      const sketch = (p) => {
        let t = 0;
        p.setup = () => {
          p.createCanvas(680, 320).parent('sketch');
          p.textFont('monospace');
        };

        function axis(x1,y1,x2,y2,label,c) {
          p.stroke(c); p.strokeWeight(2);
          p.line(x1,y1,x2,y2);
          p.noStroke(); p.fill(c); p.text(label, x2 + 6, y2 + 4);
        }

        p.draw = () => {
          p.background('#0b1020');
          p.fill('#dbeafe');
          p.noStroke();
          p.text('Tópico Vector3: vector3.divequal', 16, 24);
          p.text('Visualização genérica do vetor antes/depois', 16, 42);

          const ox = 140, oy = 250;
          axis(ox, oy, ox + 170, oy, 'X', '#60a5fa');
          axis(ox, oy, ox, oy - 140, 'Y', '#34d399');
          axis(ox, oy, ox + 90, oy - 90, 'Z', '#f59e0b');

          const before = { x: 60, y: -70, z: 35 };
          const factor = 0.5 + 0.5 * Math.sin(t);
          const after = { x: before.x * (0.7 + factor*0.8), y: before.y * (0.6 + factor*0.6), z: before.z * (0.8 + factor*0.5) };

          function drawVec(v, color, label, yText) {
            p.stroke(color); p.strokeWeight(3);
            const px = ox + v.x + v.z * 0.6;
            const py = oy + v.y - v.z * 0.6;
            p.line(ox, oy, px, py);
            p.noStroke(); p.fill(color);
            p.circle(px, py, 8);
            p.text(label + '=(' + v.x.toFixed(1) + ', ' + v.y.toFixed(1) + ', ' + v.z.toFixed(1) + ')', 360, yText);
          }

          drawVec(before, '#a78bfa', 'before', 150);
          drawVec(after, '#f43f5e', 'after ', 175);

          p.noStroke();
          p.fill('#93c5fd');
          p.text('Este esboço p5 está incorporado via HTML no MDX.', 16, 300);

          t += 0.02;
        };
      };
      new p5(sketch);
    </script>
  </body>
</html>
```

